\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{float}

\geometry{margin=1in}

\title{iTicket: A Modern Helpdesk and Ticketing System\\
       Computer \& Informatics Centre (CIC)\\
       IIT Kharagpur\\
       Design Laboratory Project Report}
\author{Technical Analysis Team}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Executive Summary}

The Computer \& Informatics Centre (CIC) at IIT Kharagpur plays a crucial role in providing IT support and services to the institute's community. Previously, support requests were handled through emails and phone calls, leading to inefficient tracking and resolution of issues. The iTicket project was developed as part of the Design Laboratory course to streamline this process by providing a modern, web-based ticketing system tailored to CIC's needs.

This system enables students, faculty, and staff to submit support requests through a structured platform, allowing for better organization, tracking, and resolution of IT-related issues. The implementation includes role-based access control, real-time communication, and AI-assisted support to enhance the efficiency of the CIC helpdesk operations.

\section{Problem Statement}

The technical problem addressed by the iTicket project is the inefficiency and complexity of support request management in organizations. Based on analysis of the codebase and commit history, the following challenges were identified:

\begin{itemize}
    \item Support requests are often managed through disparate channels (email, phone, direct messages) making it difficult to track, prioritize, and resolve them efficiently.
    \item Different types of support requests require different information and workflows, but generic ticketing systems lack customization options.
    \item Communication between support staff and users is fragmented across multiple platforms, leading to information loss and delays.
    \item There is a lack of role-based access control in many existing solutions, preventing proper separation of concerns between regular users, support staff, and administrators.
    \item Support staff lack visibility into ticket status, priorities, and assignment, making workload management difficult.
\end{itemize}

The early commit history shows an initial focus on establishing basic ticket functionality (commit 1637a1d: "Ticket functionality Added"), followed by continuous iterations to enhance communication, user management, and workflow features. The project evolved from managing simple ticket submissions to a comprehensive helpdesk system with real-time messaging, file attachments, and AI-assisted support.

\section{Objective}

The primary objectives of the iTicket project are:

\begin{enumerate}
    \item To create a centralized platform for managing support requests through a structured ticketing system with the following capabilities:
    \begin{itemize}
        \item Role-based access control separating users, helpdesk staff, and administrators
        \item Customizable ticket forms for different request types
        \item Real-time messaging between users and support staff
        \item Ticket assignment and tracking functionality
    \end{itemize}
    
    \item To improve support efficiency and transparency through:
    \begin{itemize}
        \item Clear status and priority tracking
        \item Audit trails for all ticket actions
        \item Notifications for ticket updates
        \item Dashboard analytics for performance monitoring
    \end{itemize}
    
    \item To enhance user experience with:
    \begin{itemize}
        \item User-friendly interface with modern UI components
        \item Real-time updates on ticket progress
        \item File attachment support for sharing relevant documents
        \item AI-powered chatbot assistance (added in later iterations)
    \end{itemize}
\end{enumerate}

These objectives are reflected in the feature set described in the README.md file and evidenced by the implementation in the codebase. The commit history shows a progressive enhancement of these capabilities, with major feature milestones including the implementation of ticket functionality (commit 1637a1d), chat between helpdesks and users (commit 5b5698d), and AI chatbot integration (commit 233cab6).

\section{Technology Stack}

The iTicket system is built using modern web technologies and frameworks:

\subsection{Frontend Technologies}
\begin{itemize}
    \item \textbf{Next.js 14}: React framework for server-side rendering and API routes
    \item \textbf{TailwindCSS}: Utility-first CSS framework for responsive design
    \item \textbf{React}: JavaScript library for building user interfaces
    \item \textbf{Socket.io-client}: Real-time bidirectional event-based communication
\end{itemize}

\subsection{Backend Technologies}
\begin{itemize}
    \item \textbf{Node.js}: JavaScript runtime for server-side execution
    \item \textbf{MariaDB}: Open-source relational database management system
    \item \textbf{Sequelize ORM}: Promise-based Node.js ORM for database interactions
    \item \textbf{Socket.io}: Server-side WebSocket implementation
\end{itemize}

\subsection{Authentication \& Security}
\begin{itemize}
    \item \textbf{NextAuth.js}: Authentication solution for Next.js applications
    \item \textbf{bcrypt}: Password hashing library
    \item \textbf{JSON Web Tokens (JWT)}: For secure session management
\end{itemize}

\subsection{AI Integration}
\begin{itemize}
    \item \textbf{Google Generative AI}: For AI-powered chatbot assistance
    \item \textbf{LangChain}: Framework for developing applications with LLMs
\end{itemize}

\section{System Architecture}

\subsection{Entity Relationship Diagram}

% TODO: Insert ERD diagram here
% File: diagrams/erd.png
% Caption: Entity Relationship Diagram of iTicket System

Here's the mermaid code for the ERD:

\begin{verbatim}
erDiagram
    User ||--o{ Message : "sends/receives"
    User ||--o{ FormTemplate : "creates"
    User ||--o{ FormSubmission : "submits"
    User ||--o{ TicketAssignment : "assigned to"
    User ||--o{ Notification : "receives"
    User ||--o{ TicketAudit : "performs"
    
    FormTemplate ||--o{ FormSubmission : "based on"
    FormSubmission ||--o{ Message : "contains"
    FormSubmission ||--o{ TicketAssignment : "assigned"
    FormSubmission ||--o{ TicketAudit : "tracks"
    
    Message {
        int id
        int sender_id
        int receiver_id
        int ticket_id
        text content
        datetime created_at
    }
    
    User {
        int id
        string name
        string email
        string password
        enum role
        datetime created_at
    }
    
    FormTemplate {
        int id
        string name
        json schema
        int created_by
        datetime created_at
    }
    
    FormSubmission {
        int id
        string ticket_id
        string title
        text description
        json form_data
        enum status
        enum priority
        int submitted_by
        datetime created_at
    }
    
    TicketAssignment {
        int id
        int ticket_id
        int helpdesk_id
        int assigned_by
        datetime created_at
    }
    
    TicketAudit {
        int id
        int ticket_id
        int user_id
        string action
        json changes
        datetime created_at
    }
\end{verbatim}

\subsection{User Flow Diagram}

% TODO: Insert User Flow diagram here
% File: diagrams/user_flow.png
% Caption: User Flow Diagram showing different user interactions

Here's the mermaid code for the user flow:

\begin{verbatim}
graph TD
    A[User Arrives] --> B{Has Account?}
    B -->|No| C[Sign Up]
    B -->|Yes| D[Login]
    C --> D
    D --> E{User Role?}

    %% Regular User Flow
    E -->|User| F[View Dashboard]
    F --> G[Create Ticket]
    F --> H[View My Tickets]
    H --> I[View Ticket Details]
    I --> J[Add Message]
    I --> K[View Status]

    %% Helpdesk Flow
    E -->|Helpdesk| L[View Helpdesk Dashboard]
    L --> M[View Assigned Tickets]
    L --> N[View Open Tickets]
    M --> O[Update Ticket]
    O --> P[Change Status]
    O --> Q[Add Response]
    N --> R[Assign to Self]

    %% Admin Flow
    E -->|Admin| S[View Admin Dashboard]
    S --> T[Manage Users]
    S --> U[Create Form Templates]
    S --> V[View All Tickets]
    V --> W[Assign Tickets]
    V --> X[Generate Reports]
\end{verbatim}

\subsection{Data Flow Diagram}

% TODO: Insert Data Flow diagram here
% File: diagrams/data_flow.png
% Caption: Data Flow Diagram showing system interactions

Here's the mermaid code for the data flow:

\begin{verbatim}
graph TD
    subgraph Client
        A[Web Browser] --> B[Next.js Frontend]
        B --> C[Socket.io Client]
    end

    subgraph Server
        D[Next.js API Routes]
        E[Socket.io Server]
        F[Authentication]
        G[File Storage]
    end

    subgraph Database
        H[(MariaDB)]
    end

    subgraph External
        I[Google AI API]
    end

    B <-->|HTTP/HTTPS| D
    C <-->|WebSocket| E
    D <-->|Query/Update| H
    D -->|Verify| F
    D <-->|Upload/Download| G
    D <-->|Chat Requests| I
\end{verbatim}

\section{API Documentation}

\subsection{Authentication APIs}

\subsubsection{POST /api/auth/login}
Authenticates a user and creates a session.
\begin{itemize}
    \item \textbf{Request Body}: \{email: string, password: string\}
    \item \textbf{Response}: \{user: UserObject, token: string\}
    \item \textbf{Error Codes}: 401 (Unauthorized), 400 (Bad Request)
\end{itemize}

\subsubsection{POST /api/auth/logout}
Ends the current user session.
\begin{itemize}
    \item \textbf{Response}: \{success: boolean\}
    \item \textbf{Error Codes}: 401 (Unauthorized)
\end{itemize}

\subsection{Ticket APIs}

\subsubsection{POST /api/tickets}
Creates a new ticket.
\begin{itemize}
    \item \textbf{Request Body}: \{
        title: string,
        description: string,
        form\_template\_id?: string,
        form\_data?: object,
        priority?: 'low'|'medium'|'high',
        type?: string
    \}
    \item \textbf{Response}: \{ticket: TicketObject\}
    \item \textbf{Error Codes}: 400 (Bad Request), 401 (Unauthorized)
\end{itemize}

\subsubsection{GET /api/tickets}
Retrieves tickets based on user role and filters.
\begin{itemize}
    \item \textbf{Query Parameters}: status, priority, assigned\_to, created\_by
    \item \textbf{Response}: \{tickets: TicketObject[]\}
    \item \textbf{Error Codes}: 401 (Unauthorized)
\end{itemize}

\subsubsection{GET /api/tickets/[id]}
Retrieves a specific ticket's details.
\begin{itemize}
    \item \textbf{Response}: \{ticket: TicketObject\}
    \item \textbf{Error Codes}: 404 (Not Found), 401 (Unauthorized)
\end{itemize}

\subsection{Message APIs}

\subsubsection{POST /api/chat/message}
Sends a message in a ticket thread.
\begin{itemize}
    \item \textbf{Request Body}: \{
        ticket\_id: string,
        content: string,
        attachments?: File[]
    \}
    \item \textbf{Response}: \{message: MessageObject\}
    \item \textbf{Error Codes}: 400 (Bad Request), 401 (Unauthorized)
\end{itemize}

\subsection{Form Template APIs}

\subsubsection{POST /api/forms/templates}
Creates a new form template (Admin only).
\begin{itemize}
    \item \textbf{Request Body}: \{
        name: string,
        schema: object,
        description?: string
    \}
    \item \textbf{Response}: \{template: TemplateObject\}
    \item \textbf{Error Codes}: 400 (Bad Request), 403 (Forbidden)
\end{itemize}

\section{User Interface}

% TODO: Add screenshots of the following interfaces:

\subsection{User Dashboard}
% Insert screenshot showing:
% - Ticket creation button
% - List of user's tickets
% - Status indicators
% - Search and filter options
% File: screenshots/user_dashboard.png

\subsection{Ticket Creation Form}
% Insert screenshot showing:
% - Dynamic form based on template
% - Priority selection
% - File attachment option
% File: screenshots/ticket_form.png

\subsection{Ticket Discussion Thread}
% Insert screenshot showing:
% - Message thread
% - File attachments
% - Status updates
% - Chatbot integration
% File: screenshots/ticket_thread.png

\subsection{Helpdesk Dashboard}
% Insert screenshot showing:
% - Queue of assigned tickets
% - Priority indicators
% - Performance metrics
% File: screenshots/helpdesk_dashboard.png

\subsection{Admin Interface}
% Insert screenshot showing:
% - User management
% - Form template creation
% - Analytics dashboard
% File: screenshots/admin_dashboard.png

\section{Solution}

\subsection{Architectural Approach}

The iTicket solution is built as a modern web application using Next.js framework with a client-server architecture. Key architectural decisions include:

\begin{itemize}
    \item \textbf{Framework Choice}: Next.js provides server-side rendering capabilities and API routes, allowing for a unified codebase with both frontend and backend functionality.
    
    \item \textbf{Database Design}: MariaDB/MySQL is used as the database system with Sequelize ORM for data modeling and interaction. This provides a relational database structure suited to the complex relationships between users, tickets, messages, and other entities.
    
    \item \textbf{Authentication}: NextAuth.js handles user authentication with session management, providing secure access control.
    
    \item \textbf{API-First Design}: The functionality is exposed through RESTful API endpoints, allowing for separation of concerns between the frontend UI and backend business logic.
\end{itemize}

\subsection{Database Schema}

The core data model consists of the following entities and relationships:

\begin{itemize}
    \item \textbf{Users}: Three role types (user, helpdesk, admin) with appropriate permissions
    \item \textbf{FormTemplates}: Custom ticket templates created by administrators
    \item \textbf{FormSubmissions}: Actual tickets submitted by users
    \item \textbf{Messages}: Communications attached to specific tickets
    \item \textbf{TicketAssignments}: Mapping between tickets and assigned helpdesk staff
    \item \textbf{Notifications}: System notifications for ticket updates
    \item \textbf{TicketAudit}: Audit trail tracking all ticket actions
\end{itemize}

\lstset{language=JavaScript}
\begin{lstlisting}[caption=Database Model Relationships (from models/index.js)]
// Define model relationships
User.hasMany(Message, { foreignKey: 'sender', as: 'messagesSent' });
User.hasMany(Message, { foreignKey: 'receiver', as: 'receivedMessages' });
Message.belongsTo(User, { foreignKey: 'sender', as: 'senderUser' });
Message.belongsTo(User, { foreignKey: 'receiver', as: 'receiverUser' });

// Form Templates and Submissions
User.hasMany(FormTemplate, { foreignKey: 'created_by', as: 'createdTemplates' });
FormTemplate.belongsTo(User, { foreignKey: 'created_by', as: 'creator' });

User.hasMany(FormSubmission, { foreignKey: 'submitted_by', as: 'submissions' });
FormSubmission.belongsTo(User, { foreignKey: 'submitted_by', as: 'submitter' });
FormSubmission.belongsTo(FormTemplate, { foreignKey: 'form_template_id', as: 'template', onDelete: 'CASCADE' });

// Ticket Assignment relationships
FormSubmission.hasOne(TicketAssignment, { foreignKey: 'ticket_id', as: 'assignment' });
TicketAssignment.belongsTo(FormSubmission, { foreignKey: 'ticket_id', as: 'ticket' });
\end{lstlisting}

\subsection{Key Implementation Features}

\subsubsection{Role-Based Access Control}

The application implements three distinct user roles with separate dashboards and permissions:

\begin{itemize}
    \item \textbf{Users}: Can create tickets, view their own tickets, and communicate with support staff
    \item \textbf{Helpdesk}: Can view, respond to, and update tickets assigned to them
    \item \textbf{Administrators}: Have full system access, including user management, form template creation, and analytics
\end{itemize}

This separation is enforced through route protection in the Next.js app routing system, as seen in the dashboard layout structure:

\begin{lstlisting}[caption=Dashboard Directory Structure]
/src/app/(dashboard)/
  |- admin/    # Admin-only routes
  |- helpdesk/ # Helpdesk staff routes
  |- user/     # Regular user routes
  |- layout.js # Common dashboard layout
\end{lstlisting}

\subsubsection{Customizable Ticket Forms}

Administrators can create custom ticket templates with specific fields for different request types. The implementation includes:

\begin{itemize}
    \item Form template creation and management in the admin interface
    \item Dynamic form rendering based on the selected template
    \item Structured data storage for advanced querying and reporting
\end{itemize}

This feature evolved through multiple commits, with notable enhancements in commit fdc1ac2: "drop-down option in ticket forms, helpdesk field display fixed".

\subsubsection{Real-Time Messaging}

The application enables real-time communication between users and support staff through:

\begin{itemize}
    \item Message threading attached to specific tickets
    \item Real-time updates using Socket.io
    \item File attachment support for sharing documentation
\end{itemize}

This functionality was a significant focus area, as evidenced by commit 5b5698d: "Chat between helpdesks and users for a particular ticker, Admin ticket Creation, Assign to me option".

\subsubsection{Ticket Management Workflow}

The ticket lifecycle is managed through a structured workflow:

\begin{itemize}
    \item Ticket creation with priority and type classification
    \item Assignment to helpdesk staff (manual or automatic)
    \item Status updates (open, in progress, resolved, closed)
    \item Audit trailing for all ticket actions
\end{itemize}

The ticket audit functionality was added later in the development process (commit 3f376d0: "Final edits for Attachment, Audit Trail, Logo and other UI Changes"), providing better accountability and tracking.

\subsubsection{AI-Powered Assistance}

A later addition to the project was AI chatbot integration (commit 233cab6: "Chatbot integrated"), which enhances support capabilities by:

\begin{itemize}
    \item Providing automated responses to common questions
    \item Offering self-service options for users
    \item Reducing the workload on human support staff
\end{itemize}

The implementation uses Google's Generative AI (@google/generative-ai package) as evidenced in the package.json dependencies.

\subsection{Development Evolution}

The project evolved through several phases, as evidenced by the commit history:

\begin{enumerate}
    \item \textbf{Initial Implementation (1637a1d - 10ef87c)}:
    \begin{itemize}
        \item Basic ticket functionality
        \item User authentication
        \item Simple dashboard interfaces
    \end{itemize}
    
    \item \textbf{Communication Enhancement (5b5698d - 7eab0ce)}:
    \begin{itemize}
        \item Messaging between users and helpdesk
        \item Admin messaging capabilities
        \item Ticket assignment functionality
    \end{itemize}
    
    \item \textbf{UI and UX Improvements (647b896 - 9071834)}:
    \begin{itemize}
        \item Enhanced UI design
        \item Dark mode implementation
        \item Usability enhancements
    \end{itemize}
    
    \item \textbf{Advanced Features (233cab6 - 3f376d0)}:
    \begin{itemize}
        \item AI chatbot integration
        \item File attachment support
        \item Audit trail implementation
    \end{itemize}
    
    \item \textbf{Feature Integration and Conflict Resolution (313e45e - fa4d5ab)}:
    \begin{itemize}
        \item Merging multiple feature branches
        \item Conflict resolution
        \item Final integration of chatbot and attachment features
    \end{itemize}
\end{enumerate}

\subsection{Technical Challenges and Solutions}

Several technical challenges were addressed during development:

\begin{itemize}
    \item \textbf{Database Schema Evolution}: The database schema evolved over time, requiring migration scripts. This was addressed through the comprehensive db-master.js script (2005 lines) that handles setup, migrations, and maintenance.
    
    \item \textbf{Authentication and Authorization}: Implementing secure role-based access required careful session management and route protection, solved using NextAuth.js integration.
    
    \item \textbf{Real-Time Updates}: To provide instant notifications and message delivery, Socket.io was integrated for WebSocket communication.
    
    \item \textbf{File Storage and Retrieval}: Support for file attachments required secure storage and retrieval mechanisms, implemented through API endpoints for upload and download.
    
    \item \textbf{User Experience Across Devices}: The UI needed to work well on different screen sizes, addressed through responsive design principles and Tailwind CSS.
\end{itemize}

\section{Conclusion}

\subsection{Achievements}

The iTicket project has successfully delivered a comprehensive helpdesk and ticketing system that addresses the initial problem statement and meets the defined objectives. Key achievements include:

\begin{itemize}
    \item A centralized platform for managing support requests with role-specific interfaces
    \item Customizable ticket forms that can be adapted to different request types
    \item Real-time communication capabilities between users and support staff
    \item Enhanced ticket tracking with priority, status, and assignment management
    \item AI-assisted support through chatbot integration
    \item Modern, responsive user interface with accessibility features like dark mode
\end{itemize}

The codebase demonstrates a well-structured architecture with clear separation of concerns, making it maintainable and extensible.

\subsection{Limitations}

Based on the codebase analysis, some limitations and areas for improvement include:

\begin{itemize}
    \item \textbf{Database Deployment Complexity}: The database setup and migration processes require relatively complex scripts, which could make deployment challenging for non-technical users.
    
    \item \textbf{Limited Analytics}: While the project mentions dashboard analytics in the features list, the implementation of comprehensive reporting and analytics appears to be in early stages.
    
    \item \textbf{Integration Capabilities}: The system currently lacks documented API endpoints for integration with other systems, which could limit its utility in complex enterprise environments.
    
    \item \textbf{Scalability Considerations}: The current implementation may need additional optimization for very large installations with high ticket volumes.
\end{itemize}

\subsection{Future Recommendations}

Based on the analysis, the following enhancements are recommended for future development:

\begin{enumerate}
    \item \textbf{Enhanced Analytics and Reporting}:
    \begin{itemize}
        \item Implement more comprehensive dashboard analytics
        \item Add custom report generation capabilities
        \item Include performance metrics for helpdesk staff
    \end{itemize}
    
    \item \textbf{API Documentation and Integration}:
    \begin{itemize}
        \item Document API endpoints for external consumption
        \item Create integration samples for common enterprise systems
        \item Implement webhooks for event-driven integration
    \end{itemize}
    
    \item \textbf{Scalability Enhancements}:
    \begin{itemize}
        \item Optimize database queries for large datasets
        \item Implement caching strategies for frequently accessed data
        \item Consider microservices architecture for specific components
    \end{itemize}
    
    \item \textbf{Advanced AI Capabilities}:
    \begin{itemize}
        \item Expand chatbot functionality with more training data
        \item Add automatic ticket categorization and routing
        \item Implement sentiment analysis for user messages
    \end{itemize}
    
    \item \textbf{Deployment Simplification}:
    \begin{itemize}
        \item Create containerized deployment options (Docker)
        \item Simplify database setup and migration processes
        \item Add cloud deployment templates for common platforms
    \end{itemize}
\end{enumerate}

\subsection{Final Assessment}

The iTicket project represents a well-executed solution to the problem of support request management. Its role-based design, customizable forms, and real-time communication features provide a solid foundation for efficient helpdesk operations. The architecture demonstrates good software engineering practices, with clear separation of concerns and a modular approach that facilitates future expansion.

With the recommended enhancements, particularly in the areas of analytics, integration, and deployment simplification, the system could become an even more compelling solution for organizations of various sizes seeking to improve their support operations.

\end{document} 